\documentclass{article}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb}
\usepackage{parskip}
\usepackage{graphicx}

% Margins
\usepackage[top=2.5cm, left=3cm, right=3cm, bottom=4.0cm]{geometry}
% Colour table cells
\usepackage[table]{xcolor}

\newcommand{\tablespace}{\\[1.25mm]}
\newcommand\Tstrut{\rule{0pt}{2.6ex}}         % = `top' strut
\newcommand\tstrut{\rule{0pt}{2.0ex}}         % = `top' strut
\newcommand\Bstrut{\rule[-0.9ex]{0pt}{0pt}}   % = `bottom' strut

%%%%%%%%%%%%%%%%%
%     Title     %
%%%%%%%%%%%%%%%%%
\title{Scientific Computing Using Python - Assignment}
\author{Shreyas Srinivasa \\ shsr@es.aau.dk}
\date{\today}

\begin{document}
\maketitle

\section{Implementation}
The implementation for the assignment is performed with $4$ methods as suggested in the tasks. Implementation with each method is described below:

\subsection{Naive Version}
%Naive version%
The naive version is implemented with $2$-D arrays and $3$ methods: \textit{linspace()}, \textit{mandel\_naive()} and \textit{mandel\_set\_naive()}.
\begin{itemize}
    \item \textit{linspace(start, stop, n)} is used for creation of array with the start, stop and n variables denoting the range and the size. As per the project specification document, the values for start and stop are initialized. The function returns an array. The function is called for determining the real and imaginary parts of the array elements.
    \item \textit{mandel\_naive(c, maxiter, threshold)} calculates the value of \textit{z} as per the iterations and checks for the value bound for the threshold specified. The function returns the value for the mandelbrot set.
    \item \textit{mandel\_set\_naive(xmin,xmax,ymin,ymax,width,height,maxiter, threshold)} computes the mandelbrot set by initializing the real and imaginary parts. The parameters \textit{width} and \textit{height} represent the $p_{r_e}$ and $p_{i_m}$, \textit{maxiter} denotes the maximum iterations \textit{I} and the threshold represents \textit{T} . The function returns a list with the mandelbrot set. 
\end{itemize}

 
\subsection{Numba Version}
%Numba version%
The Numba version is similar to the naive version with an exception of using Numba \textit{@jit} decorator on top of the \textit{mandel\_naive()} function. As we run the program with multiple methods in a sequential execution, a seperate method is created called \textit{mandel\_numba()} with the \textit{@jit} decorator.

\subsection{Numba-Vectorized Version}
%Numba vectorised%
The vectorized version adds the \textit{@vectorize} decorator to create numba \textit{ufuncs} for parallelization. In the vectorization version, the method that computes the values for the mandelbrot set are changed to optimize the computation. The optimization is done through factoring out the redundant calculations by passing the real and imaginary parts of the complex numbers directly to the mandel function and calculating their squares separately only once and avoiding the square root computation by equations $1$, $2$ and $3$ that denote the definition of the square of complex numbers, the absolute value, and the sum of two complex numbers.

\begin{equation}
    (a+bi)^2=(a+bi)(a+bi)=(a^2-b^2)+2abi
   \end{equation}
\begin{equation}
    \left |(a+bi) \right |= \sqrt{a^2+b^2}
\end{equation}
\begin{equation}
       (a+bi)+(c+di)=(a+c)+(b+d)i
\end{equation}

The script \textit{variant.py} calls for parallelization of the method \textit{mandel\_numba\_vect} that computes the values for the mandelbrot set. The default number of threads set by numba in NUMBA\_NUM\_THREADS is $8$. On running the script, the vectorized methods run with this default value. However, to compare the execution time with different threads, the script \textit{vectorized.py} is called with a shell script \textit{vectorished.sh}. The number of script can be set in the shell script.  On executing the shell script, the execution time for the computation of the mandeset is shown on the console. 


\subsection{Multiprocessing Version}
%Multiprocessing%




\section{Output}

\subsection{Plots}

\subsection{Execution Time}

\subsection{Simulation Data}


\section{Software Design}

\subsection{Design Considerations}

\subsection{Optimization Considerations}

\subsection{Algorithm}

\section{Test Plan}



\section{Profiling and Benchmarking}

\begin{align}
    \begin{array}{c | c | c}
         Method  & Execution Time & Speedup \\ 
         \hline % horizontal line
         Naive-Numpy   &  & -8 \\
         Numba      &  &    \\
         Numba - Vectorized &  & 5 \\
         Multiprocessing &  & 1 \\
    \end{array}
\end{align}



\begin{align}
    \begin{array}{c | c | c}
         Processor  & Computation Time & Speedup \\ 
         \hline % horizontal line
         1   &  & -8 \\
         2   &  &  6  \\
         3   &  & 5 \\
         4   &  & 1 \\
         5   &  & 1 \\
         6   &  & 1 \\
         7   &  & 1 \\
         8   &  & 1 \\
    \end{array}
\end{align}



\end{document}
